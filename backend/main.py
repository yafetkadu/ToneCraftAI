# Imports 
from fastapi import FastAPI, HTTPException, Depends, status
from pydantic import BaseModel
from typing import Annotated
import models
from db.database import Base, engine
from models.models import UserModel, EmailModel
from db.database import engine, SessionLocal
from sqlalchemy.orm import Session

#Schemas
# Import user schemas
from schemas.user_schema import UserCreate, UserLogin

# Import email schemas
from schemas.email_schema import EmailRequest, EmailResponse




#from dotenv import load_dotenv
import os


# Setups
app = FastAPI()
Base.metadata.create_all(bind=engine)

# validating requests


# Dependincy for our database (whenever you want to access the database we call this method)
def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close() 

db_dependency = Annotated[Session, Depends(get_db)]

# API end Points

@app.get('/')
def index():
    return {"message": "API READY"}


@app.get('/welcome')
def index():
    return {"message": "Welcome to ToneCraft Write your Emails Professionally"}

# USER ROUTES

'''
Suggested Routes
Method	Endpoint	Purpose
POST	/auth/signup	Create a new user with email + username
POST	/auth/login	Login and get session/token
GET	/user/me	Get logged-in user info (protected)
POST	/generate	Input: original email + selected tone â†’ Output: rewritten email
GET	/tokens	Check remaining tokens for the user
POST	/tokens/use	Deduct tokens when generating an email
GET	/history	(Optional) Get all emails generated by user

'''

# AUTH ROUTES USER/SIGNUP

@app.post('/auth/signup', status_code=status.HTTP_201_CREATED)
async def signup_user(user: UserCreate, db: Session = Depends(get_db)):
    existing_user = db.query(UserModel).filter(UserModel.email == user.email).first()
    if existing_user:
        raise HTTPException(status_code=400, detail="Email already exists")
    
    #hashed_pw = auth.hash_password(user.password)

    new_user = UserModel(
        firstname=user.firstname,
        lastname=user.lastname,
        email=user.email,
        password=user.password
    )

    db.add(new_user)
    db.commit()
    db.refresh(new_user)
    return user

@app.post("/auth/login")
def login():
    pass

@app.get("/user/me") # must be authenticated
def get_profile():
    pass

##################################
######### Email ROutes #############
@app.post("/generate") # must be authenticated
def genereate_professional_email():
    pass

@app.get("/history") # must be authenticated
def get_email_history():
    pass

#########################
########### Token ROutes ##############
@app.get("/tokens") # must be authenticated
def check_tokens():
    pass

@app.post("/tokens/use") # must be authenticated
def use_tokens():
    pass


# LOGIN ROUTE WHICH RETURNS THE LOGGED IN USERS TOKEN
# LOGOUT
